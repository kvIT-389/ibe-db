/******************************************************************************/
/***          Generated by IBExpert 2021.3.29.1 23.06.2023 7:34:01          ***/
/******************************************************************************/

/******************************************************************************/
/***      Following SET SQL DIALECT is just for the Database Comparer       ***/
/******************************************************************************/
SET SQL DIALECT 3;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GROUPS_GENERATOR;

CREATE GENERATOR SUBJECTS_GENERATOR;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION GRADE_EXISTS_ERROR 'Данный студент уже имеет оценку по данному предмету.';

CREATE EXCEPTION GROUP_EXISTS_ERROR 'Такая группа уже существует.';

CREATE EXCEPTION GROUP_NOT_EMPTY_ERROR 'Группа не может быть удалена, так как содержит студентов.';

CREATE EXCEPTION STUDENT_EXISTS_ERROR 'Студент с таким номером зачетки уже существует.';

CREATE EXCEPTION SUBJECT_EXISTS_ERROR 'Предмет с таким названием уже существует.';



/******************************************************************************/
/***                           Stored procedures                            ***/
/******************************************************************************/



SET TERM ^ ;

CREATE PROCEDURE DELETE_GRADE (
    RECORD_BOOK_ID INTEGER,
    SUBJECT_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_GROUP (
    GROUP_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_STUDENT (
    RECORD_BOOK_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_SUBJECT (
    SUBJECT_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE GROUP_GRADES (
    GROUP_FULL_CIPHER VARCHAR(10))
RETURNS (
    STUDENT_FULL_NAME VARCHAR(62),
    SUBJECT_NAME VARCHAR(30),
    GRADE VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GROUP_GRADES_AVERAGE (
    GROUP_FULL_CIPHER VARCHAR(10))
RETURNS (
    STUDENT_FULL_NAME VARCHAR(62),
    GRADE_AVERAGE NUMERIC(3,2))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE INSERT_GRADE (
    RECORD_BOOK_ID INTEGER,
    SUBJECT_ID INTEGER,
    GRADE VARCHAR(3))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE INSERT_GROUP (
    GROUP_CIPHER VARCHAR(5),
    STUDY_BEGIN_YEAR INTEGER,
    GROUP_NUMBER INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE INSERT_STUDENT (
    RECORD_BOOK_ID INTEGER,
    LAST_NAME VARCHAR(20),
    FIRST_NAME VARCHAR(20),
    MIDDLE_NAME VARCHAR(20),
    BIRTH_DATE DATE,
    GENDER VARCHAR(1),
    GROUP_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE INSERT_SUBJECT (
    SUBJECT_NAME VARCHAR(30),
    HOURS_NUMBER INTEGER,
    CERTIFICATION_TYPE VARCHAR(3))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE STUDENTS_STUDIED_SUBJECT (
    SUBJECT_NAME VARCHAR(30))
RETURNS (
    GROUP_FULL_CIPHER VARCHAR(10),
    STUDENT_FULL_NAME VARCHAR(62),
    GRADE VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE STUDENTS_TOTAL_HOURS_RANGE (
    MIN_TOTAL_HOURS INTEGER,
    MAX_TOTAL_HOURS INTEGER)
RETURNS (
    GROUP_FULL_CIPHER VARCHAR(10),
    STUDENT_FULL_NAME VARCHAR(62),
    TOTAL_HOURS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE UPDATE_GRADE (
    RECORD_BOOK_ID INTEGER,
    SUBJECT_ID INTEGER,
    GRADE VARCHAR(3))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE UPDATE_GROUP (
    GROUP_ID INTEGER,
    GROUP_CIPHER VARCHAR(5),
    STUDY_BEGIN_YEAR INTEGER,
    GROUP_NUMBER INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE UPDATE_STUDENT (
    RECORD_BOOK_ID INTEGER,
    LAST_NAME VARCHAR(20),
    FIRST_NAME VARCHAR(20),
    MIDDLE_NAME VARCHAR(20),
    BIRTH_DATE DATE,
    GENDER VARCHAR(1),
    GROUP_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE UPDATE_SUBJECT (
    SUBJECT_ID INTEGER,
    SUBJECT_NAME VARCHAR(30),
    HOURS_NUMBER INTEGER,
    CERTIFICATION_TYPE VARCHAR(3))
AS
BEGIN
  EXIT;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE GRADES (
    RECORD_BOOK_ID  INTEGER NOT NULL,
    SUBJECT_ID      INTEGER NOT NULL,
    GRADE           VARCHAR(3) NOT NULL
);

CREATE TABLE GROUPS (
    GROUP_ID           INTEGER NOT NULL,
    GROUP_CIPHER       VARCHAR(5) NOT NULL,
    STUDY_BEGIN_YEAR   INTEGER NOT NULL,
    GROUP_NUMBER       INTEGER NOT NULL,
    GROUP_FULL_CIPHER  COMPUTED BY (group_cipher||'-'||cast(mod(study_begin_year,100) as varchar(2))||'-'||cast(group_number as varchar(1)))
);

CREATE TABLE STUDENTS (
    RECORD_BOOK_ID  INTEGER NOT NULL,
    LAST_NAME       VARCHAR(20) NOT NULL,
    FIRST_NAME      VARCHAR(20) NOT NULL,
    MIDDLE_NAME     VARCHAR(20) NOT NULL,
    BIRTH_DATE      DATE NOT NULL,
    GENDER          VARCHAR(1) NOT NULL,
    GROUP_ID        INTEGER NOT NULL,
    FULL_NAME       COMPUTED BY (last_name||' '||first_name||' '||middle_name)
);

CREATE TABLE SUBJECTS (
    SUBJECT_ID          INTEGER NOT NULL,
    SUBJECT_NAME        VARCHAR(30) NOT NULL,
    HOURS_NUMBER        INTEGER NOT NULL,
    CERTIFICATION_TYPE  VARCHAR(3) NOT NULL
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: EXCELLENT_STUDENTS */
CREATE VIEW EXCELLENT_STUDENTS(
    GROUP_FULL_CIPHER,
    STUDENT_FULL_NAME)
AS
select G.group_full_cipher, S.full_name
  from students S
  join groups G on S.group_id=G.group_id
  where '5' = all(
    select GR.grade
      from grades GR
      join subjects SB on GR.subject_id=SB.subject_id
      where GR.record_book_id=S.record_book_id
        and SB.certification_type='ЭКЗ'
  )
  order by G.group_full_cipher, S.last_name
;



/* View: STATEMENTS */
CREATE VIEW STATEMENTS(
    GROUP_FULL_CIPHER,
    STUDENT_FULL_NAME,
    SUBJECT_NAME,
    GRADE)
AS
select G.group_full_cipher, S.full_name, SB.subject_name, GR.grade
  from grades GR
  join subjects SB on GR.subject_id=SB.subject_id
  join students S on GR.record_book_id=S.record_book_id
  join groups G on S.group_id=G.group_id
  order by G.group_full_cipher, S.last_name, SB.subject_name
;




/******************************************************************************/
/***                           Check constraints                            ***/
/******************************************************************************/

ALTER TABLE STUDENTS ADD CHECK (gender='М' OR gender='Ж');
ALTER TABLE SUBJECTS ADD CHECK (certification_type='ЗАЧ' OR certification_type='ЭКЗ');


/******************************************************************************/
/***                              Primary keys                              ***/
/******************************************************************************/

ALTER TABLE GRADES ADD PRIMARY KEY (RECORD_BOOK_ID, SUBJECT_ID);
ALTER TABLE GROUPS ADD PRIMARY KEY (GROUP_ID);
ALTER TABLE STUDENTS ADD PRIMARY KEY (RECORD_BOOK_ID);
ALTER TABLE SUBJECTS ADD PRIMARY KEY (SUBJECT_ID);


/******************************************************************************/
/***                              Foreign keys                              ***/
/******************************************************************************/

ALTER TABLE GRADES ADD FOREIGN KEY (RECORD_BOOK_ID) REFERENCES STUDENTS (RECORD_BOOK_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE GRADES ADD FOREIGN KEY (SUBJECT_ID) REFERENCES SUBJECTS (SUBJECT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE STUDENTS ADD FOREIGN KEY (GROUP_ID) REFERENCES GROUPS (GROUP_ID) ON DELETE NO ACTION ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE UNIQUE INDEX GROUP_INDEX ON GROUPS (GROUP_CIPHER, STUDY_BEGIN_YEAR, GROUP_NUMBER);


/******************************************************************************/
/***                           Stored procedures                            ***/
/******************************************************************************/



SET TERM ^ ;

ALTER PROCEDURE DELETE_GRADE (
    RECORD_BOOK_ID INTEGER,
    SUBJECT_ID INTEGER)
AS
begin
  delete from grades GR where GR.record_book_id=:record_book_id
                          and subject_id=:subject_id;
end^


ALTER PROCEDURE DELETE_GROUP (
    GROUP_ID INTEGER)
AS
declare variable C integer;
begin
  select count(*) from students S
    where S.group_id=:group_id
    into :c;

  if (:c=0) then
    delete from groups G where G.group_id=:group_id;
  else
    exception group_not_empty_error;
end^


ALTER PROCEDURE DELETE_STUDENT (
    RECORD_BOOK_ID INTEGER)
AS
declare variable C integer;
begin
  delete from students S where S.record_book_id=:record_book_id;
end^


ALTER PROCEDURE DELETE_SUBJECT (
    SUBJECT_ID INTEGER)
AS
begin
  delete from subjects SB where SB.subject_id=:subject_id;
end^


ALTER PROCEDURE GROUP_GRADES (
    GROUP_FULL_CIPHER VARCHAR(10))
RETURNS (
    STUDENT_FULL_NAME VARCHAR(62),
    SUBJECT_NAME VARCHAR(30),
    GRADE VARCHAR(3))
AS
begin
  for select S.full_name, SB.subject_name, GR.grade
      from grades GR
      join subjects SB on GR.subject_id=SB.subject_id
      join students S on GR.record_book_id=S.record_book_id
      join groups G on S.group_id=G.group_id
      where upper(G.group_full_cipher)=upper(:group_full_cipher)
        and SB.certification_type='ЭКЗ'
      order by S.last_name, SB.subject_name
      into :student_full_name, :subject_name, :grade do

  suspend;
end^


ALTER PROCEDURE GROUP_GRADES_AVERAGE (
    GROUP_FULL_CIPHER VARCHAR(10))
RETURNS (
    STUDENT_FULL_NAME VARCHAR(62),
    GRADE_AVERAGE NUMERIC(3,2))
AS
begin
  for select S.full_name, avg(cast(GR.grade as numeric(3,2)))
      from grades GR
      join subjects SB on GR.subject_id=SB.subject_id
      join students S on GR.record_book_id=S.record_book_id
      join groups G on S.group_id=G.group_id
      where upper(G.group_full_cipher)=upper(:group_full_cipher)
        and SB.certification_type='ЭКЗ'
      group by S.full_name
      order by S.full_name
      into :student_full_name, :grade_average do

  suspend;
end^


ALTER PROCEDURE INSERT_GRADE (
    RECORD_BOOK_ID INTEGER,
    SUBJECT_ID INTEGER,
    GRADE VARCHAR(3))
AS
declare variable C integer;
begin
  select count(*) from grades GR
    where GR.record_book_id=:record_book_id
      and GR.subject_id=:subject_id
    into :c;

  if (:c=0) then
    insert into grades values (:record_book_id, :subject_id, :grade);
  else
    exception grade_exists_error;
end^


ALTER PROCEDURE INSERT_GROUP (
    GROUP_CIPHER VARCHAR(5),
    STUDY_BEGIN_YEAR INTEGER,
    GROUP_NUMBER INTEGER)
AS
declare variable C integer;
begin
  select count(*) from groups G
    where G.group_cipher=:group_cipher
      and G.study_begin_year=:study_begin_year
      and G.group_number=:group_number
    into :c;

  if (:c=0) then
    insert into groups values
      (gen_id(groups_generator,1), :group_cipher,
       :study_begin_year, :group_number);
  else
    exception group_exists_error;
end^


ALTER PROCEDURE INSERT_STUDENT (
    RECORD_BOOK_ID INTEGER,
    LAST_NAME VARCHAR(20),
    FIRST_NAME VARCHAR(20),
    MIDDLE_NAME VARCHAR(20),
    BIRTH_DATE DATE,
    GENDER VARCHAR(1),
    GROUP_ID INTEGER)
AS
declare variable C integer;
begin
  select count(*) from students S
    where S.record_book_id=:record_book_id
    into :c;

  if (:c=0) then
    insert into students values
      (:record_book_id, :last_name, :first_name, :middle_name,
       :birth_date, :gender, :group_id);
  else
    exception student_exists_error;
end^


ALTER PROCEDURE INSERT_SUBJECT (
    SUBJECT_NAME VARCHAR(30),
    HOURS_NUMBER INTEGER,
    CERTIFICATION_TYPE VARCHAR(3))
AS
declare variable C integer;
begin
  select count(*) from subjects SB
    where SB.subject_name=:subject_name
    into :c;

  if (:c=0) then
    insert into subjects values
      (gen_id(subjects_generator,1), :subject_name,
       :hours_number, :certification_type);
  else
    exception subject_exists_error;
end^


ALTER PROCEDURE STUDENTS_STUDIED_SUBJECT (
    SUBJECT_NAME VARCHAR(30))
RETURNS (
    GROUP_FULL_CIPHER VARCHAR(10),
    STUDENT_FULL_NAME VARCHAR(62),
    GRADE VARCHAR(3))
AS
begin
  for select G.group_full_cipher, S.full_name, GR.grade
      from grades GR
      join subjects SB on GR.subject_id=SB.subject_id
      join students S on GR.record_book_id=S.record_book_id
      join groups G on S.group_id=G.group_id
      where upper(SB.subject_name)=upper(:subject_name)
      order by G.group_full_cipher, S.full_name
      into :group_full_cipher, :student_full_name, :grade do

  suspend;
end^


ALTER PROCEDURE STUDENTS_TOTAL_HOURS_RANGE (
    MIN_TOTAL_HOURS INTEGER,
    MAX_TOTAL_HOURS INTEGER)
RETURNS (
    GROUP_FULL_CIPHER VARCHAR(10),
    STUDENT_FULL_NAME VARCHAR(62),
    TOTAL_HOURS INTEGER)
AS
begin
  for select G.group_full_cipher, S.full_name, sum(SB.hours_number)
      from grades GR
      join subjects SB on GR.subject_id=SB.subject_id
      join students S on GR.record_book_id=S.record_book_id
      join groups G on S.group_id=G.group_id
      group by G.group_full_cipher, S.full_name
      having sum(SB.hours_number)
        between :min_total_hours and :max_total_hours
      order by G.group_full_cipher, S.full_name
      into :group_full_cipher, :student_full_name, :total_hours do

  suspend;
end^


ALTER PROCEDURE UPDATE_GRADE (
    RECORD_BOOK_ID INTEGER,
    SUBJECT_ID INTEGER,
    GRADE VARCHAR(3))
AS
begin
  update grades GR set
    GR.grade=:grade
  where GR.record_book_id=:record_book_id
    and GR.subject_id=:subject_id;
end^


ALTER PROCEDURE UPDATE_GROUP (
    GROUP_ID INTEGER,
    GROUP_CIPHER VARCHAR(5),
    STUDY_BEGIN_YEAR INTEGER,
    GROUP_NUMBER INTEGER)
AS
declare variable C integer;
begin
  update groups G set
    G.group_cipher=:group_cipher,
    G.study_begin_year=:study_begin_year,
    G.group_number=:group_number
  where G.group_id=:group_id;

  select count(*) from groups G
    where G.group_cipher=:group_cipher
      and G.study_begin_year=:study_begin_year
      and G.group_number=:group_number
    into :c;

  if (:c>1) then
    exception group_exists_error;
end^


ALTER PROCEDURE UPDATE_STUDENT (
    RECORD_BOOK_ID INTEGER,
    LAST_NAME VARCHAR(20),
    FIRST_NAME VARCHAR(20),
    MIDDLE_NAME VARCHAR(20),
    BIRTH_DATE DATE,
    GENDER VARCHAR(1),
    GROUP_ID INTEGER)
AS
begin
  update students S set
    S.first_name=:first_name,
    S.last_name=:last_name,
    S.middle_name=:middle_name,
    S.birth_date=:birth_date,
    S.gender=:gender,
    S.group_id=:group_id
  where S.record_book_id=:record_book_id;
end^


ALTER PROCEDURE UPDATE_SUBJECT (
    SUBJECT_ID INTEGER,
    SUBJECT_NAME VARCHAR(30),
    HOURS_NUMBER INTEGER,
    CERTIFICATION_TYPE VARCHAR(3))
AS
declare variable C integer;
begin
  update subjects SB set
    SB.subject_name=:subject_name,
    SB.hours_number=:hours_number,
    SB.certification_type=:certification_type
  where SB.subject_id=:subject_id;

  select count(*) from subjects SB
    where SB.subject_name=:subject_name
    into :c;

  if (:c>1) then
    exception subject_exists_error;
end^



SET TERM ; ^
